# Pad4All

Pad4all is a synthetiser coded in python, adjustable to your need.  
It features :
- a Looper
- a Virtual keyboard
- 1 Oscillator
- 1 ADSR enveloppe 
- Effects : Delay, Saturation and Glide

This project was developed as part of the 2nd year project at Polytech Nantes. Originally, Pad4all is a raspberry pi synthesizer. This version is an export from the school's private repository.

## How to use it
### Requirement

Run ```pip install -r requirement.txt``` to install all the libraries needed.

The main file is ```pad4all.py``` . It will run the synth (```looper_midi.py``` ) and the virtual keyboard  (```vkeyboard.py```) at the same time.  

The connection between the 2 files should be done by default. Unless you're a windows user then you'll need to install [loopMIDI](https://www.tobias-erichsen.de/software/loopmidi.html).

However, the virtual keyboard only allows a limited version of the synth, as it doesn’t feature any elements that can shape its sound.

To use pad4all to its full extent, you'll need your own midi device. In that case simply run ```synth_midi.py``` or ```looper_midi.py```. 

### Set-up

The ```config.py``` file allows you to configure each midi connections based on your midi device. Run it to check what midi signal each of your keys and buttons are returning.

It will print a list of a various midi info sent by your device every time you trigger a button. 

As an inside almost every parameter of pad4all is linked with the first value of the list.

### Effects overview

- ```WAVETYPE_NOTE``` is linked to the waveform generated by the oscillator. Each tap on it switches between the 4 basics (sine, triangle, sawtooth, square). It's what primarily changes the tone of a synth.

-  ```ATTACK_NOTE```, ```DECAY_NOTE```, ```SUSTAIN_NOTE```, ```RELEASE_NOTE``` are each linked to the 4 stages of the [ADSR](https://en.wikipedia.org/wiki/Envelope_(music)) envelope, which modulates the volume of a played note.


- Delay effect repeats the signal just played. ```DELAY_NOTE``` changes the amount of delayed signals,  ```MIX_NOTE``` how loud the effect is and  ```FEEDBACK_NOTE``` how fast the volume decreases.

- Saturation effect distort the signal, ```DRIVE_NOTE``` and ```SOFTEN_NOTE``` changes how soft the distortion is.

- ```GLIDE_NOTE``` is linked to the duration of the glide effect that creates a pitch slide at the beginning of note.

#### Looper 

The looper has 2 loop. 

- Pressing ```RECORD_1``` start a recording that stop when you press it again. The loop will played instantly afterward. 
- ```PLAY_1``` will mute the loop, press it again to unmute it. 
- Press ```RECORD_1``` a third time to delete your loop and start over.

It works the same for the second loop.

However, when you record your first loop ever (must be loop 1) this will "initiate" the looper. It will fix a ```LENGTH``` for the full session.
By all means the second loop will automatically be ```LENGTH```'s multiple long for syncing reason.

If you want to resert the  ```LENGTH``` factor you'll need to start a new session by pressing ```RESET```. 

-  ```VOL_L ``` is linked to volume of the looper.

## How it works
### Code Structure

![HTML logo](files/classdiagram.png)

### Class ```Oscillator``` 

```python
from osc import *
import matplotlib.pyplot as plt

# create an oscillator instance
osc = iter(Oscillator(wave_type=0,freq=440))

# stock osc values in a list
samples = [next(osc) for _ in range(256)]

# show samples
plt.plot(samples)
plt.show()
```
The ```Oscillator``` class works as an iterator that generate wave values.

Once instantiated, each iteration advances one step in the waveform and returns the corresponding value.

You can modify the parameters in the code above to see the different waveform.

The ```Oscillator``` class also supports dynamic frequency modulation using ```@property``` and ```@setter```. If frequency is modified externally, it will automatically
update the step value. 


### Class ```EnveloppeADSR``` 
```python
from adsr import *
import matplotlib.pyplot as plt

# create an oscillator instance
adsr = iter(EnveloppeADSR(attack=0.2,decay=0.2,sustain=0.5,release=1))

# stock osc values in a list
samples = [next(adsr) for _ in range(44100)]

#trigger release
adsr.switch_to_r()

samples += [next(adsr) for _ in range(44100)]

# show samples
plt.plot(samples)
plt.show()
```
The ```EnveloppeADSR``` class works as an iterator that generates values between 0 and 1 based on the ```attack```, ```decay```, ```sustain``` and ```release``` parameters.

It contains two generator ```ADS()``` and ```R()``` which handle attack–decay–sustain and release stages respectively.

The current generator, stored in ```stepper```,  switches when ```switch_to_r()``` or ```switch_to_ads()``` is called externally.

Once instantiated, each iteration advances one step in  ```stepper``` and returns the corresponding value. 

Next, we'll see how it is paired with the ```Oscillator``` class to shape its amp parameter.

### Class ```ModulatedOscillator``` 

```python
from mod_osc import *
import matplotlib.pyplot as plt

# create instances
osc = Oscillator(wave_type=1,freq=440)
amp = EnveloppeADSR(attack=0.05,decay=0.01,sustain=0.5,release=0.01)

mod_osc = iter(ModulatedOscillator(oscillator=osc,modulator=amp))

# stock mod_osc values in a list
samples = [next(mod_osc) for _ in range(4096)]

# show samples
plt.plot(samples)
plt.show()
```

The ```ModulatedOscillator``` class works as an iterator that 
combine the ```EnveloppeADSR``` and ```Oscillator``` class.

It also stores all additionnal effect. Currently, these include delay, glide, and a simple saturation.

Without any effects, each iteration advances one step in  ```oscillator``` and ```modulator``` returns the multiplication of both. 

#### Glide :

It shapes the frequency of oscillator, starting an octave below the initial frequency and rises until it reaches it.

```glide_time``` : Duration of the pitch glide.

#### Delay :

It repeats the note played, each repetition gradually decreases in amplitude over time until it fades to zero.

```delay_length``` : Interval between each repeated signal.

```delay_feedback_time``` : "Numbers" of repeated signals.

```delay_amp```  : Volume of the repeated signals are.

For more explanation you can check [here](https://en.wikipedia.org/wiki/Delay_(audio_effect)).

This delay effect begins as soon as the release stage is complete. At that point, ``` _delay_init``` is called to initialize the delay by storing the signal data in a list.

After initialization, this list is read at each iteration.

#### Saturation :

It apply a soft distortion to the signal. This [code](https://stackoverflow.com/questions/23284531/clipping-tops-of-waveforms-in-python) is the reference.

```linear_limit``` : Set the threshold of the effect, any signal above is distorded.

```soften``` : Controls how soft the effect is. By all means it's how gradually the distortion effect increases depending on how much above the signal is to the threshold.


### Class ```Synth```

The ```Synth``` class operates the synth. It handles incoming midi signals and manages the audio stream simultaneously. It translates midi events into audio data and sends that data to the audio output stream.

```midi_callback()``` : This function is executed every time a midi event occurs and reacts according to the type of midi message receive,

- Key pressed : Creates a ```ModulatedOscillator``` instance corresponding to the played note and stores it in ```notes```. 
- Knob twisted : Updates the associated parameter.
- Key released : Set the note's ADSR to its release stage.

```stream_callback()``` : This function iterates all the oscillator instances stored and sums it. It returns an audio buffer , which the audio stream continuously reads.

```play()``` : This function starts a session and keeps it active. It also removes any oscillator from ```notes``` if it finished playing.

### Class ```audioLoop```


The ```audioLoop``` class manages a complete loop. It contains all the necessary tools to record, build, and read a loop. The loop data is stored in ```main_audio```.

```add_buffer()``` : Copies incoming data into ```main_audio```.

```initialize()``` : Prepares the recorded loop for playback. It creates a crossfade between the end and the beginning of the loop (to avoid any clicking). It also  initializes the read pointer to the correct position to avoid synchronization issues. 

 ```read()``` : Iterates through the loop data and returns the current audio buffer.

```set_recording()``` : Starts or stops the recording, depending on the current loop state.

- If starting, it sets ```is_waiting``` to true, meaning the user has requested recording but is now waiting for it to actually begins.

- If stopping, it calls ```initialize()```.

```clear()``` : Reset the loop.

```toggle_mute()``` : Mutes or unmutes the loop. Muting it set ```is_playing``` to false, causing ```read()``` to return silence instead of the stored loop.

### Class ```Looper```

This part of the code, would haven't been possible without the help of this [code](https://github.com/RandomVertebrate/raspi-looper).

The ```Loop``` class inherits from the ```Synth``` class. It adds a metronome and loop management to ```midi_callback()``` and ```stream_callback()```.

The first recording initializes the looper. It sets the value of  ```LENGTH```, a variable shared between the ```Looper``` and ```audioLoop``` classes.
```setup_initialized``` is also set to true.

When the ```RESET``` parameter is triggered, all loops are re-instanciated and the looper returns to an uninitialized state.

When a record is triggered, ```midi_callback()``` set a loop to the waiting state. Then ```synth_callback()``` waits until the looper reaches the beginning of the cycle before switching the loop from waiting to recording.
